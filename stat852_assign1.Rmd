---
title: "Stat852 Assignment 1"
author: "Matthew Reyers"
date: "September 18, 2019"
output: html_document
---
# General
In interest of practicing some newer styles of coding, I have reworked most of the sample code. The general format is more closely adhering to Tidyverse code than it is to the base R version. As such, I will try to provide comments where I can to provide clarity.

# Lecture 2b)
The focus of this lecture has been on variable selection methods. Results are to be displayed and interpreted as per the corresponding questions.

1. a) Make a table of training and test error for the best model model built on eachhalf using each criterion in the program (sMSE, BIC, MSPE). Comment on the consistency of the results between the two halves: what is consistent and what is not. What does the consistency (or lack thereof) suggest about the relative importance of these variables.

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(magrittr)
library(leaps)
library(knitr)
library(conflicted)
conflict_prefer("extract", "magrittr")
conflict_prefer("filter", "dplyr")

prostate <-  read.table("C:/Users/mreyers/Documents/GitHub/GradStatWork/Prostate.csv", header=TRUE, sep=",", na.strings=" ")
# head(prostate)

# Splitting data in half using random uniform selection to make two "set"s.
# Also performs the regression and stores the results / summary within the tibble for easy access
set.seed(120401002) 
prostate_tidy <- prostate %>%
  as.data.frame() %>%
  mutate(set = ifelse(runif(n = nrow(prostate)) > 0.5, "set1", "set2")) %>%
  nest(-set) %>%
  mutate(regsubs = map(data, ~ regsubsets(x = as.matrix(.x[, c(2:9)]), y = as.matrix(.x[, 10]),
                                          nbest = 1))) %>%
  mutate(summ_results = map(regsubs, ~ summary(.x)))

# Function I will need shortly
basic_reg <- function(data, n_vars, sizes){
  data <- data %>% select(-ID, -train)
  sizes <- sizes[, -1] # dont need intercept term manually listed
  if(n_vars == 0){
    return(lm(lpsa ~ 1, data = data))
  } else{
    return(lm(lpsa ~ ., data = data[, c(sizes[n_vars, ], TRUE)])) # Manually add in the response variable
  }
}

# Grabs the matrix of T/F values for regsubset models, the first one is for set1, the other set2
model_sizes_1 <- prostate_tidy %>% slice(1) %>% pull(summ_results) %>% extract2(1) %>% extract('which')
model_sizes_2 <- prostate_tidy %>% slice(2) %>% pull(summ_results) %>% extract2(1) %>% extract('which')

# Stuff for newdata later
set1 <- prostate_tidy %>%
  filter(set %in% "set1")
set2 <- prostate_tidy %>%
  filter(set %in% "set2")

# This combines the models with the necessary measurements (sMSE, BIC, MSPE) through extensive use of mapping
prostate_models_train1 <- prostate_tidy %>%
  filter(set %in% "set1") %>%
  mutate(n_vars = list(0:8)) %>% 
  unnest(.preserve = c(data, regsubs, summ_results)) %>%
  mutate(model_sizes = list(as.matrix(model_sizes_1$which)),
         reg_results = pmap(list(data, n_vars, model_sizes), ~ basic_reg(..1, ..2, ..3))) %>%
  mutate(sMSE = map_dbl(reg_results, ~ summary(.x)$sigma^2),
         BIC = pmap_dbl(list(reg_results, data), ~ extractAIC(..1, k = log(nrow(..2)))[2])) %>%
  mutate(new_data = set2$data,
         predictions = map2(reg_results, new_data, ~ predict(.x, newdata = .y)),
         MSPE = map2_dbl(predictions, new_data, ~ mean((.x - .y$lpsa)^2))) %>%
  select(n_vars, sMSE, BIC, MSPE, reg_results)

sMSE_model_1 <- prostate_models_train1 %>%
  filter(sMSE == min(sMSE)) %>%
  pull(reg_results) %>%
  extract2(1) %>%
  summary() %>%
  use_series(coefficients) %>%
  extract(,1)

BIC_model_1 <- prostate_models_train1 %>%
  filter(BIC == min(BIC)) %>%
  pull(reg_results) %>%
  extract2(1) %>%
  summary() %>%
  use_series(coefficients) %>%
  extract(,1)

MSPE_model_1 <- prostate_models_train1 %>%
  filter(MSPE == min(MSPE)) %>%
  pull(reg_results) %>%
  extract2(1) %>%
  summary() %>%
  use_series(coefficients) %>%
  extract(,1)
# prostate_models_train1 %>% slice(3) %>% pull(reg_results) %>% extract2(1) %>% summary()

# This does the same as the above but with respect to training on set2 and predicting on set1
prostate_models_train2 <- prostate_tidy %>%
  filter(set %in% "set2") %>%
  mutate(n_vars = list(0:8)) %>% 
  unnest(.preserve = c(data, regsubs, summ_results)) %>%
  mutate(model_sizes = list(as.matrix(model_sizes_2$which)),
         reg_results = pmap(list(data, n_vars, model_sizes), ~ basic_reg(..1, ..2, ..3))) %>%
  mutate(sMSE = map_dbl(reg_results, ~ summary(.x)$sigma^2),
         BIC = pmap_dbl(list(reg_results, data), ~ extractAIC(..1, k = log(nrow(..2)))[2])) %>%
  mutate(new_data = set1$data,
         predictions = map2(reg_results, new_data, ~ predict(.x, newdata = .y)),
         MSPE = map2_dbl(predictions, new_data, ~ mean((.x - .y$lpsa)^2))) %>%
  select(n_vars, sMSE, BIC, MSPE, reg_results)

sMSE_model_2 <- prostate_models_train2 %>%
  filter(sMSE == min(sMSE)) %>%
  pull(reg_results) %>%
  extract2(1) %>%
  summary() %>%
  use_series(coefficients) %>%
  extract(,1)

BIC_model_2 <- prostate_models_train2 %>%
  filter(BIC == min(BIC)) %>%
  pull(reg_results) %>%
  extract2(1) %>%
  summary() %>%
  use_series(coefficients) %>%
  extract(,1)

MSPE_model_2 <- prostate_models_train2 %>%
  filter(MSPE == min(MSPE)) %>%
  pull(reg_results) %>%
  extract2(1) %>%
  summary() %>%
  use_series(coefficients) %>%
  extract(,1)
# My understanding is that the base code has the groups reversed, meaning that my results will be in 
# the opposite order of what is expected (set1 for me I believe is labelled as 2 in original code)
```

The corresponding table for the first seed value is as follows:


```{r, output=FALSE}
set.seed(9267926) 
prostate_tidy <- prostate %>%
  as.data.frame() %>%
  mutate(set = ifelse(runif(n = nrow(prostate)) > 0.5, "set1", "set2")) %>%
  nest(-set) %>%
  mutate(regsubs = map(data, ~ regsubsets(x = as.matrix(.x[, c(2:9)]), y = as.matrix(.x[, 10]),
                                          nbest = 1))) %>%
  mutate(summ_results = map(regsubs, ~ summary(.x)))

# Function I will need shortly
basic_reg <- function(data, n_vars, sizes){
  data <- data %>% select(-ID, -train)
  sizes <- sizes[, -1] # dont need intercept term manually listed
  if(n_vars == 0){
    return(lm(lpsa ~ 1, data = data))
  } else{
    return(lm(lpsa ~ ., data = data[, c(sizes[n_vars, ], TRUE)])) # Manually add in the response variable
  }
}

# Grabs the matrix of T/F values for regsubset models, the first one is for set1, the other set2
model_sizes_1 <- prostate_tidy %>% slice(1) %>% pull(summ_results) %>% extract2(1) %>% extract('which')
model_sizes_2 <- prostate_tidy %>% slice(2) %>% pull(summ_results) %>% extract2(1) %>% extract('which')

# Stuff for newdata later
set1 <- prostate_tidy %>%
  filter(set %in% "set1")
set2 <- prostate_tidy %>%
  filter(set %in% "set2")

# This combines the models with the necessary measurements (sMSE, BIC, MSPE) through extensive use of mapping
prostate_models_train1 <- prostate_tidy %>%
  filter(set %in% "set1") %>%
  mutate(n_vars = list(0:8)) %>% 
  unnest(.preserve = c(data, regsubs, summ_results)) %>%
  mutate(model_sizes = list(as.matrix(model_sizes_1$which)),
         reg_results = pmap(list(data, n_vars, model_sizes), ~ basic_reg(..1, ..2, ..3))) %>%
  mutate(sMSE = map(reg_results, ~ summary(.x)$sigma^2),
         BIC = pmap(list(reg_results, data), ~ extractAIC(..1, k = log(nrow(..2)))[2])) %>%
  mutate(new_data = set2$data,
         predictions = map2(reg_results, new_data, ~ predict(.x, newdata = .y)),
         MSPE = map2(predictions, new_data, ~ mean((.x - .y$lpsa)^2))) %>%
  select(n_vars, sMSE, BIC, MSPE)

# This does the same as the above but with respect to training on set2 and predicting on set1
prostate_models_train2 <- prostate_tidy %>%
  filter(set %in% "set2") %>%
  mutate(n_vars = list(0:8)) %>% 
  unnest(.preserve = c(data, regsubs, summ_results)) %>%
  mutate(model_sizes = list(as.matrix(model_sizes_2$which)),
         reg_results = pmap(list(data, n_vars, model_sizes), ~ basic_reg(..1, ..2, ..3))) %>%
  mutate(sMSE = map(reg_results, ~ summary(.x)$sigma^2),
         BIC = pmap(list(reg_results, data), ~ extractAIC(..1, k = log(nrow(..2)))[2])) %>%
  mutate(new_data = set1$data,
         predictions = map2(reg_results, new_data, ~ predict(.x, newdata = .y)),
         MSPE = map2(predictions, new_data, ~ mean((.x - .y$lpsa)^2))) %>%
  select(n_vars, sMSE, BIC, MSPE)
```

The code above is what I used to generate the data as per the original code. Below is the table of corresponding results.

```{r}
# Add code for the table here
```


Thoughts on the above:

Below are some extra plots to display a few trends throughout the results. I find it makes the data more easily interpretable.
```{r, echo=FALSE}

prostate_models_train1 %>%
  gather(Metric, Value, -n_vars) %>%
  ggplot(aes(x = n_vars, y = as.numeric(Value))) +
  geom_line() +
  geom_point() +
  ggtitle("Performance by Metric for Training Set 1") +
  xlab("Best Model with given Number of Variables") + ylab("Value") +
  facet_wrap(~ Metric, scales = "free")

prostate_models_train2 %>%
  gather(Metric, Value, -n_vars) %>%
  ggplot(aes(x = n_vars, y = as.numeric(Value))) +
  geom_line() +
  geom_point() +
  ggtitle("Performance by Metric for Training Set 2") +
  xlab("Best Model with given Number of Variables") + ylab("Value") +
  facet_wrap(~ Metric, scales = "free")

# Together
prostate_models_train1 %>%
  mutate(model = "Model 1") %>%
  bind_rows(prostate_models_train2 %>% mutate(model = "Model 2")) %>%
  gather(Metric, Value, -n_vars, -model) %>%
  ggplot(aes(x = n_vars, y = as.numeric(Value), group = model, color = model)) +
  geom_line() +
  geom_point() +
  ggtitle("Performance by Metric for Both Training Sets") +
  xlab("Best Model with given Number of Variables") + ylab("Value") +
  facet_wrap(~ Metric, scales = "free")
```

